[{"/Users/pknipp/Desktop/repos/react-frontend-template/src/index.js":"1","/Users/pknipp/Desktop/repos/react-frontend-template/src/App.js":"2","/Users/pknipp/Desktop/repos/rotating-body/src/index.js":"3","/Users/pknipp/Desktop/repos/rotating-body/src/App.js":"4","/Users/pknipp/Desktop/repos/rotating-body/src/Input.js":"5","/Users/pknipp/Desktop/repos/rotating-body/src/Square.js":"6","/Users/pknipp/Desktop/repos/rotating-body/src/Line.js":"7","/Users/pknipp/Desktop/repos/rotating-body/src/Body.js":"8","/Users/pknipp/Desktop/repos/rotating-body/src/Dot.js":"9"},{"size":506,"mtime":1611765216984,"results":"10","hashOfConfig":"11"},{"size":64,"mtime":1611765000156,"results":"12","hashOfConfig":"11"},{"size":506,"mtime":1611765216984,"results":"13","hashOfConfig":"14"},{"size":16313,"mtime":1615639178753,"results":"15","hashOfConfig":"14"},{"size":326,"mtime":1615562911283,"results":"16","hashOfConfig":"14"},{"size":858,"mtime":1615332940600,"results":"17","hashOfConfig":"14"},{"size":717,"mtime":1615334427283,"results":"18","hashOfConfig":"14"},{"size":1918,"mtime":1615638242518,"results":"19","hashOfConfig":"14"},{"size":279,"mtime":1615603398365,"results":"20","hashOfConfig":"14"},{"filePath":"21","messages":"22","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},"1s2inzs",{"filePath":"23","messages":"24","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"25","messages":"26","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"27"},"3yxk78",{"filePath":"28","messages":"29","errorCount":0,"warningCount":5,"fixableErrorCount":0,"fixableWarningCount":0,"source":"30"},{"filePath":"31","messages":"32","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"27"},{"filePath":"33","messages":"34","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"35"},{"filePath":"36","messages":"37","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"27"},{"filePath":"38","messages":"39","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"40","messages":"41","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"27"},"/Users/pknipp/Desktop/repos/react-frontend-template/src/index.js",[],"/Users/pknipp/Desktop/repos/react-frontend-template/src/App.js",[],"/Users/pknipp/Desktop/repos/rotating-body/src/index.js",[],["42","43"],"/Users/pknipp/Desktop/repos/rotating-body/src/App.js",["44","45","46","47","48"],"import React, { useState, useEffect } from \"react\";\nimport { EigenvalueDecomposition, Matrix } from \"ml-matrix\";\nimport Dot from \"./Dot\";\nimport Input from \"./Input\";\nimport Line from \"./Line\";\n// import Square from \"./Square\";\nimport Body from \"./Body\";\n\nconst App = () => {\n    const nx = 700;\n    const ny = 700;\n    // following is solely needed for list comprehensions\n    const [xyz] = useState(new Array(3).fill(0));\n    // const colors = [\"red\", \"green\", \"blue\"];\n    const [LzInput, setLzInput] = useState(\"1\");\n    const [Lz, setLz] = useState(Number(LzInput));\n    const [thsInput, setThsInput] = useState([\"0.2\", \"0.3\", \"0.4\"]);\n    const [ths, setThs] = useState(thsInput.map(elem => Number(elem)));\n    const [momsInput, setMomsInput] = useState([\"2\", \"3\", \"4\"]);\n    const [firstMoms, setFirstMoms] = useState(momsInput.map(elem => Number(elem)));\n    const [moms, setMoms] = useState(momsInput.map(elem => Number(elem)));\n    const [omsInput] = useState([\"\", \"\", \"\"]);\n    const [oms, setOms] = useState(omsInput.map(elem => Number(elem)));\n    const [omfs, setOmfs] = useState([0, 0, 0]);\n    const [, setLs] = useState([0, 0, 0]);\n    const [labLs, setLabLs] = useState([0, 0, 0]);\n    const [om2, setOm2] = useState(0);\n    const [omf, setOmf] = useState(0);\n    const [L2, setL2] = useState(0);\n    const [K, setK] = useState(0);\n    const [mids0, setMids0] = useState([]);\n    const [mids, setMids] = useState([]);\n    const [running, setRunning] = useState(false);\n    const [time, setTime] = useState(0);\n    // const [angleVecs, setAngleVecs] = useState([[]]);\n    const [angleVec, setAngleVec] = useState([]);\n    const [d, setD] = useState([nx / 3, nx / 3, nx / 3]);\n    const [areLegalMoms, setAreLegalMoms] = useState(true);\n    const [degeneracies, setDegeneracies] = useState(new Array(3).fill(false));\n    const [shape, setShape] = useState(0);\n    const [types, setTypes] = useState([]);\n    const [zAxis, setZAxis] = useState(0);\n    const [legalOrder, setLegalOrder] = useState(true);\n    const [isotropic, setIsotropic] = useState(false);\n\n    // ODE-solver timestep in ms\n    const dt = 50;\n\n    // helpful linear algebra functions:\n    const dotproduct = (vec1, vec2) => vec1.reduce((dot, comp, i) => dot + comp * vec2[i], 0);\n    const mult1 = (mat, vec) => mat.map(row => dotproduct(row, vec));\n    const transpose = mat => mat[0].map((blah, i) => mat.map(row => row[i]));\n    const mult2 = (mat1, mat2) => mat1.map(x => transpose(mat2).map(y => dotproduct(x, y)));\n\n    const zRot = th => {\n        let [c, s] = [Math.cos(th), Math.sin(th)];\n        return [[c, s, 0], [-s, c, 0], [0, 0, 1]];\n    }\n    const xRot = th => {\n        let [c, s] = [Math.cos(th), Math.sin(th)];\n        return [[1, 0, 0], [0, c, s], [0, -s, c]];\n    }\n\n    // const rot = ths => mult2(mult2(zRot(ths[2]), xRot(ths[1])), zRot(ths[0]));\n    const invRot=ths=> mult2(mult2(zRot(-ths[0]),xRot(-ths[1])), zRot(-ths[2]));\n\n    useEffect(() => {\n        let sumMom = moms[0] + moms[1] + moms[2];\n        let newD = moms.map(mom => Math.max(0.000001, Math.sqrt((sumMom / 2 - mom))));\n        let dMax = newD.reduce((max, d) => Math.max(d, max));\n        newD = newD.map(d => nx * d / dMax / 4);\n        setD(newD);\n        // replace this using reduce or forEach?\n        const newMids0 = [];\n        xyz.forEach((row, i) => {\n            let mid1 = [...xyz];\n            mid1[i] = newD[i];\n            let mid2 = [...xyz];\n            mid2[i] = -newD[i];\n            newMids0.push(mid1, mid2);\n        })\n        setMids0(newMids0);\n    }, [moms, xyz]);\n\n    const rotationStuff = () => {\n        setMids(mids0.map((mid, i) => mult1(invRot(ths), mid)));\n        setAngleVec(rotate(invRot(ths)));\n    }\n    useEffect(() => rotationStuff(), [mids0, ths]);\n\n    const rotate = mat => {\n        let trace = mat[0][0] + mat[1][1] + mat[2][2];\n        let angle = Math.acos((trace - 1) / 2);\n        let vectors = new EigenvalueDecomposition(new Matrix(mat)).eigenvectorMatrix.transpose().data;\n        // Determine which eigenvector has eigenvalue = 1 (ie, is rotation axis)\n        let dVectors = vectors.map(vector => mult1(mat, vector).map((comp, i) => comp - vector[i]));\n        let mags = dVectors.map(dVector => dVector.reduce((mag, comp) => mag + comp * comp, 0));\n        let min = mags.reduce((min, mag, i) => mag < min[1] ? [i, mag] : min, [-1, Infinity]);\n        let axisVec = vectors[min[0]];\n        let vec = vectors[(min[0] + 1) % 3];\n        let rVec = mult1(mat, vec);\n        // rewrite this using a double loop or double list-comprehension?\n        let rVecCrossVec = [rVec[1] * vec[2] - rVec[2] * vec[1],\n                            rVec[2] * vec[0] - rVec[0] * vec[2],\n                            rVec[0] * vec[1] - rVec[1] * vec[0]];\n        angle *= Math.sign(dotproduct(axisVec, rVecCrossVec));\n        return [angle, axisVec];\n    }\n\n    // consolidate aspects of following event handlers?\n    const handlerLz = e => {\n        let newLz =  e.target.value;\n        if (['', '-', '.', '-.'].includes(newLz)) return setLzInput(newLz);\n        if (isNaN(Number(newLz))) return;\n        setLzInput(newLz);\n        setLz(Number(newLz));\n    };\n\n    const handlerTh = e => {\n        let xyOrZ = Number(e.target.name);\n        let th =  e.target.value;\n        let newThsInput = [...thsInput]\n        let newThs = [...ths];\n        if (['', '-','.', '-.'].includes(th)) {\n            newThsInput[xyOrZ] = th;\n        } else {\n            if (isNaN(Number(th))) return;\n            newThsInput[xyOrZ] = th;\n            newThs[xyOrZ] = Number(th);\n        }\n        setThsInput(newThsInput);\n        setThs(newThs);\n        let newMids = [];\n        mids0.forEach(mid => newMids.push(mult1(invRot(ths), mid)));\n        setMids(newMids);\n    };\n\n    const handlerMom = e => {\n        // let xyOrZ = Number(e.target.name);\n        let newIsotropic = false;\n        let name = Number(e.target.name);\n        let mom = e.target.value;\n        let newMomsInput = [...momsInput];\n        let newMoms = [...firstMoms];\n        if (['', '.'].includes(mom)) {\n            newMomsInput[name] = mom;\n        } else {\n            let newMom = Number(mom);\n            if (isNaN(newMom)) return;\n            newMomsInput[name] = mom;\n            newMoms[name] = newMom;\n            if (shape === 1) {\n                newMoms[1] = newMom;\n                newMoms[2] = newMom;\n            }\n            if (shape === 2) {\n                if (name === 1) newMoms[2] = newMom;\n                if (newMoms[0] === newMoms[1]) newIsotropic = true;\n            }\n            if (shape === 3) setLegalOrder(newMoms.reduce((legal, mom, i, moms) => (!i || (legal && mom > moms[i - 1])), true))\n            setAreLegalMoms(newMoms.reduce((legal, mom, i, moms) => (legal && mom <= (moms[(i+1)%3] + moms[(i+2)%3])), true));\n        }\n        setIsotropic(newIsotropic);\n        setMomsInput(newMomsInput);\n        setFirstMoms(newMoms);\n        setMoms(newMoms);\n    };\n\n    useEffect(() => {\n        let interval;\n        if (running) interval = setInterval(() => setTime(time + dt/1000), dt);\n        if (!running && time !== 0) clearInterval(interval);\n        return () => clearInterval(interval);\n    }, [running, time]);\n\n    const Fs = ths => {\n        let cs = [];\n        let ss = [];\n        for (const th of ths) {\n            cs.push(Math.cos(th));\n            ss.push(Math.sin(th));\n        };\n        let Fs = []\n        Fs[0] = Lz * (cs[2] * cs[2] / moms[1] + ss[2] * ss[2] / moms[0]);\n        Fs[1] = Lz * (1 / moms[0] - 1 / moms[1]) * ss[1] * ss[2] * cs[2];\n        Fs[2] = Lz * (1 / moms[2] - cs[2] * cs[2] / moms[1] - ss[2] * ss[2] / moms[0]) * cs[1];\n        let newOms = [];\n        newOms[0] = Fs[0] * ss[1] * ss[2] + Fs[1] * cs[2];\n        newOms[1] = Fs[0] * ss[1] * cs[2] - Fs[1] * ss[2];\n        newOms[2] = Fs[0] * cs[1] + Fs[2];\n        setOms(newOms);\n        setOm2(newOms.reduce((om2, om) => om2 + om * om, 0));\n        let newOmfs = [];\n        newOmfs[0] = Fs[2] * ss[1] * ss[0] + Fs[1] * cs[0];\n        newOmfs[1] =-Fs[2] * ss[1] * cs[0] + Fs[1] * ss[0];\n        newOmfs[2] = Fs[2] * cs[1] + Fs[0];\n        setOmfs(newOmfs);\n        setOmf(Math.sqrt(newOmfs.reduce((om2, om) => om2 + om * om, 0)));\n        let newLs = newOms.map((om, i) => moms[i] * om);\n        setLs(newLs);\n        setL2(newLs.reduce((L2, L) => L2 + L * L, 0));\n        setLabLs(mult1(invRot(ths), newLs));\n        setK(newLs.reduce((K, L, i) => K + L * oms[i], 0)/2);\n        return Fs;\n    }\n\n    const nextFs = (intFs, m) => Fs(ths.map((th, i) => th + intFs[i] * dt / 1000 / m));\n\n    // With each \"tick\", calculate the next set of 3 Euler angles\n    useEffect(() => {\n        if (!running) return;\n        let Fs1 = Fs(ths);\n        let Fs2 = nextFs(Fs1, 2);\n        let Fs3 = nextFs(Fs2, 2);\n        let Fs4 = nextFs(Fs3, 1);\n        setThs([...ths].map((th, i) => th + (Fs1[i] + Fs4[i] + 2 * (Fs2[i] + Fs3[i])) * dt/ 1000 / 6));\n    }, [time, running]);\n    return (\n        <>\n            <div className=\"top\"><p align=\"center\"><h1>Free-body rotation</h1></p></div>\n            <div className=\"bottom\">\n            <div className=\"left\">\n            {!zAxis ? null :\n                <>\n                <p align=\"center\"><h3>Controls</h3></p>\n                <button onClick={() => setRunning(!running)}>{running ? \"Stop\" : \"Start\"}</button>\n                <button onClick={() => setTime(0)}>Reset</button>\n                Time = {time.toFixed(2)} s\n                </>\n            }\n            <p align=\"center\"><h3>Inputs</h3></p>\n            <div><i>z</i>-component of angular momentum</div>\n            <Input quantity={running || time ? Lz : LzInput} handler={handlerLz}/> kg m/s\n            <br/><br/>\n\n            <div>Shape of box</div>\n            <select value={shape} onChange={e => {\n                let newShape = Number(e.target.value);\n                setShape(newShape);\n                setZAxis(newShape === 1 ? 1 : 0);\n                setRunning(false);\n                setTime(0);\n                setDegeneracies([[false, false, false], [true, true, true], [false, true, true], [false, false, false]][newShape]);\n                let newMoms = [...moms];\n                if (newShape === 1) newMoms = newMoms.map((mom, i, moms) => moms[0])\n                if (newShape === 2) {\n                    newMoms[1] = newMoms[1] === newMoms[0] ? Math.round(newMoms[0] + 0.6) : newMoms[1];\n                    newMoms[2] = newMoms[1];\n                }\n                if (newShape === 3) {\n                    newMoms.sort((a, b) => a - b);\n                    newMoms[1] = newMoms[1] === newMoms[0] ? Math.round(newMoms[0] + 0.6) : newMoms[1];\n                    newMoms[2] = newMoms[2] <= newMoms[1] ? Math.round(newMoms[1] + 0.6) : newMoms[2];\n                }\n                setMomsInput(newMoms.map(mom => String(mom)));\n                setFirstMoms(newMoms);\n                setMoms(newMoms);\n                setTypes([[''], ['generic'], ['parallel', 'transverse'], ['longest', 'intermediate', 'shortest']][newShape]);\n            }}>\n                {[\"choose shape\", 'isotropic', 'axisymmetric', 'asymmetric'].map((option, i) => (\n                    <option key={i} title={\"more info\"} value={i}>\n                        {option}\n                    </option>\n                ))}\n            </select>\n            <br/><br/>\n\n            {!shape ? null :\n                <>\n                <div>Moment{`${shape === 1 ? '' : \"s\"}`} of inertia: (in kg m<sup>2</sup>)</div>\n                {xyz.filter((blah, i) => i < shape).map((blah, i) => (\n                    <div>\n                        <Input key={i} name={i} quantity={momsInput[i]} handler={handlerMom} />\n                        {types[i]} axis\n                    </div>\n                ))}\n                {legalOrder ? null : <div className=\"message\">For an asymmetric body the moments of inertia should increase, going from long axis to short axis.</div>}\n                {areLegalMoms ? null : <div className=\"message\">No single moment of inertia should exceed the sum of the other two.</div>}\n                {!isotropic ? null : <div className=\"message\">This is considered \"isotropic\" not \"axisymmetric\".</div>}\n                <br/><br/>\n\n                {shape < 1 ? null :\n                    <>\n                    <div>Choose <i>z</i>-axis to be near ...</div>\n                    <select value={zAxis} onChange={e => {\n                        let newZAxis = Number(e.target.value);\n                        let newMoms = [...moms];\n                        newMoms[2] = firstMoms[newZAxis - 1];\n                        newMoms[0] = firstMoms[newZAxis % 3];\n                        newMoms[1] = firstMoms[(newZAxis + 1) % 3];\n                        setMoms(newMoms);\n                        setZAxis(newZAxis);\n                        setRunning(false);\n                        setTime(0);\n                        setOms([0, 0, 0]);\n                        setOmfs([0, 0, 0]);\n                        // set as \"true\" for all axes for which moments of inertia are degenerate\n                        let newDegeneracies = newMoms.map((momI, i) => {\n                            return newMoms.reduce((degenerate, momJ, j) => {\n                                return degenerate || (momJ === momI && i !== j);\n                            }, false);\n                        })\n                        setDegeneracies(newDegeneracies);\n                    }}>\n                        {[\"which\", ...types].map((option, i) => (\n                            <option key={i} value={i}>{option} </option>\n                        ))}\n                    </select> axis\n                    <p align=\"center\"><h3>{zAxis && time ? \"Data\" : null}</h3></p>\n                    {!zAxis ? null :\n                        <>\n                        <div>Euler angles (in radians):</div>\n                        <div>between {types[zAxis - 1]} axis and <i>z</i>-axis:</div>\n                        <div>\n                            &theta; = <Input key={\"ang1\"} name={1} quantity={running || time ? ths[1] : thsInput[1]} handler={handlerTh} />\n                        </div>\n                        <div>Remaining two angles:</div>\n                        <div>\n                            &phi; = <Input\n                                key={\"ang0\"} name={0} handler={handlerTh}\n                                quantity={running || time ? ths[0] : thsInput[0]}\n                            />\n                            &psi; = <Input\n                                key={\"ang0\"} name={2} handler={handlerTh}\n                                quantity={running || time ? ths[2] : thsInput[2]}\n                            />\n                        </div>\n                        </>\n                    }\n                    </>\n                }\n                <br/>\n\n                {!(running || time) ? null :\n                    <>\n                    <div>Lab-frame angular velocity (in rad/sec)</div>\n                    <div>(also displayed as a segment in figure):</div>\n                    <div>components = [\n                        {Math.round(omfs[0] * 1000) / 1000},&nbsp;\n                        {Math.round(omfs[1] * 1000) / 1000},&nbsp;\n                        {Math.round(omfs[2] * 1000) / 1000}\n                        ]\n                    </div>\n                    <div>magnitude = {Math.round(omf * 1000) / 1000}</div>\n                    <br/><br/>\n                    <div>kinetic energy = {Math.round(1000 * K) / 1000} joules</div>\n                    </>\n                }\n                </>\n            }\n\n            </div>\n            <div className=\"container\" style={{height:`${ny}px`, width:`${nx}px`}}>\n                {mids.map((mid, i) => (\n                    degeneracies[Math.floor(i / 2)] ? null :\n                        <Line xi={nx/2} yi={ny/2} xf={nx * (0.5 + mid[0]/d[Math.floor(i / 2)]/10)} yf={ny * (0.5 + mid[1]/d[Math.floor(i / 2)]/10)} dashed={true} />\n                ))}\n                <Line xi={nx/2} yi={ny/2} xf={nx/2 + nx * omfs[0]/omf/2} yf={ny/2 + nx * omfs[1]/omf/2} />\n                <Body nx={nx} ny={ny} angleVec={angleVec} d={d} dt={dt} />\n                <Dot x={nx/2} y={ny/2} d={10} />\n            </div>\n            </div>\n        </>\n    )\n}\nexport default App;\n","/Users/pknipp/Desktop/repos/rotating-body/src/Input.js",[],"/Users/pknipp/Desktop/repos/rotating-body/src/Square.js",[],["49","50"],"/Users/pknipp/Desktop/repos/rotating-body/src/Line.js",[],"/Users/pknipp/Desktop/repos/rotating-body/src/Body.js",[],"/Users/pknipp/Desktop/repos/rotating-body/src/Dot.js",[],{"ruleId":"51","replacedBy":"52"},{"ruleId":"53","replacedBy":"54"},{"ruleId":"55","severity":1,"message":"56","line":26,"column":12,"nodeType":"57","messageId":"58","endLine":26,"endColumn":17},{"ruleId":"55","severity":1,"message":"59","line":27,"column":12,"nodeType":"57","messageId":"58","endLine":27,"endColumn":15},{"ruleId":"55","severity":1,"message":"60","line":29,"column":12,"nodeType":"57","messageId":"58","endLine":29,"endColumn":14},{"ruleId":"61","severity":1,"message":"62","line":89,"column":38,"nodeType":"63","endLine":89,"endColumn":50,"suggestions":"64"},{"ruleId":"61","severity":1,"message":"65","line":217,"column":8,"nodeType":"63","endLine":217,"endColumn":23,"suggestions":"66"},{"ruleId":"51","replacedBy":"67"},{"ruleId":"53","replacedBy":"68"},"no-native-reassign",["69"],"no-negated-in-lhs",["70"],"no-unused-vars","'labLs' is assigned a value but never used.","Identifier","unusedVar","'om2' is assigned a value but never used.","'L2' is assigned a value but never used.","react-hooks/exhaustive-deps","React Hook useEffect has a missing dependency: 'rotationStuff'. Either include it or remove the dependency array.","ArrayExpression",["71"],"React Hook useEffect has missing dependencies: 'Fs', 'nextFs', and 'ths'. Either include them or remove the dependency array. You can also do a functional update 'setThs(t => ...)' if you only need 'ths' in the 'setThs' call.",["72"],["69"],["70"],"no-global-assign","no-unsafe-negation",{"desc":"73","fix":"74"},{"desc":"75","fix":"76"},"Update the dependencies array to be: [mids0, rotationStuff, ths]",{"range":"77","text":"78"},"Update the dependencies array to be: [time, running, Fs, ths, nextFs]",{"range":"79","text":"80"},[3751,3763],"[mids0, rotationStuff, ths]",[8944,8959],"[time, running, Fs, ths, nextFs]"]