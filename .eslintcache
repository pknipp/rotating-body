[{"/Users/pknipp/Desktop/repos/front-ends/rotating-body/src/index.js":"1","/Users/pknipp/Desktop/repos/front-ends/rotating-body/src/App.js":"2","/Users/pknipp/Desktop/repos/front-ends/rotating-body/src/InputNumber.js":"3","/Users/pknipp/Desktop/repos/front-ends/rotating-body/src/ToggleInfo.js":"4","/Users/pknipp/Desktop/repos/front-ends/rotating-body/src/Body.js":"5","/Users/pknipp/Desktop/repos/front-ends/rotating-body/src/Dot.js":"6","/Users/pknipp/Desktop/repos/front-ends/rotating-body/src/Line.js":"7"},{"size":506,"mtime":1611765216984,"results":"8","hashOfConfig":"9"},{"size":28861,"mtime":1617977329027,"results":"10","hashOfConfig":"9"},{"size":566,"mtime":1617976776723,"results":"11","hashOfConfig":"9"},{"size":563,"mtime":1615760788034,"results":"12","hashOfConfig":"9"},{"size":3013,"mtime":1615773151842,"results":"13","hashOfConfig":"9"},{"size":279,"mtime":1615603398365,"results":"14","hashOfConfig":"9"},{"size":493,"mtime":1617974571728,"results":"15","hashOfConfig":"9"},{"filePath":"16","messages":"17","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"18"},"1pph1t6",{"filePath":"19","messages":"20","errorCount":0,"warningCount":7,"fixableErrorCount":0,"fixableWarningCount":0,"source":"21","usedDeprecatedRules":"18"},{"filePath":"22","messages":"23","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"18"},{"filePath":"24","messages":"25","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"18"},{"filePath":"26","messages":"27","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"28"},{"filePath":"29","messages":"30","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"18"},{"filePath":"31","messages":"32","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"18"},"/Users/pknipp/Desktop/repos/front-ends/rotating-body/src/index.js",[],["33","34"],"/Users/pknipp/Desktop/repos/front-ends/rotating-body/src/App.js",["35","36","37","38","39","40","41"],"import React, { useState, useEffect } from \"react\";\nimport { EigenvalueDecomposition, Matrix } from \"ml-matrix\";\nimport Dot from \"./Dot\";\n// import Input from \"./Input\";\nimport InputNumber from \"./InputNumber\";\nimport Line from \"./Line\";\nimport ToggleInfo from \"./ToggleInfo\";\nimport Body from \"./Body\";\nimport info from \"./info.png\";\nimport cancel from \"./cancel.jpeg\";\nconst App = () => {\n    const allTypes = [[], ['generic'], ['parallel', 'transverse'], ['longest',    'intermediate',    'shortest']];\n    const allStabilities = [[], ['constant'], ['precession', 'marginally unstable'], ['precession', 'unstable', 'precession']];\n    // following is solely needed for list comprehensions\n    const [xyz] = useState(new Array(3).fill(0));\n    const [npx, setNpx] = useState(700);\n    // const [LzInput, setLzInput] = useState(\"4\");\n    const [Lz, setLz] = useState(4);\n    const [thsInput, setThsInput] = useState([\"0.2\", \"0.3\", \"0.4\"]);\n    const [ths, setThs] = useState(thsInput.map(elem => Number(elem)));\n    const [momsInput, setMomsInput] = useState([\"2\", \"3\", \"4\"]);\n    const [firstMoms, setFirstMoms] = useState(momsInput.map(elem => Number(elem)));\n    const [moms, setMoms] = useState([...firstMoms]);\n    const [oms, setOms] = useState([]);\n    const [omfs, setOmfs] = useState([0, 0, 0]);\n    const [omfLat, setomfLat] = useState(0);\n    const [omfAng, setOmfAng] = useState(null);\n    const [, setLs] = useState([0, 0, 0]);\n    // const [labLs, setLabLs] = useState([0, 0, 0]);\n    // const [om2, setOm2] = useState(0);\n    const [omf, setOmf] = useState(0);\n    // const [L2, setL2] = useState(0);\n    const [K, setK] = useState(0);\n    const [mids0, setMids0] = useState([]);\n    const [, setMids] = useState([]);\n    const [running, setRunning] = useState(false);\n    const [time, setTime] = useState(0);\n    // const [angleVecs, setAngleVecs] = useState([[]]);\n    const [angleVec, setAngleVec] = useState([]);\n    const [d, setD] = useState([npx / 3, npx / 3, npx / 3]);\n    const [areLegalMoms, setAreLegalMoms] = useState(true);\n    const [degeneracies, setDegeneracies] = useState(new Array(3).fill(false));\n    const [shape, setShape] = useState(3);\n    const [types, setTypes] = useState(allTypes[shape]);\n    const [stabilities, setStabilities] = useState(allStabilities[shape]);\n    const [zAxis, setZAxis] = useState(2);\n    const [legalOrder, setLegalOrder] = useState(true);\n    const [isotropic, setIsotropic] = useState(false);\n    const [logDt, setLogDt] = useState(7);\n    const [dt, setDt] = useState(2 ** logDt);\n    const [showInfo, setShowInfo] = useState({});\n    const [perspective, setPerspective] = useState(npx);\n    // helpful linear algebra functions:\n    const dotproduct = (vec1, vec2) => vec1.reduce((dot, comp, i) => dot + comp * vec2[i], 0);\n    const mult1 = (mat, vec) => mat.map(row => dotproduct(row, vec));\n    const transpose = mat => mat[0].map((blah, i) => mat.map(row => row[i]));\n    const mult2 = (mat1, mat2) => mat1.map(x => transpose(mat2).map(y => dotproduct(x, y)));\n    const zRot = th => {\n        let [c, s] = [Math.cos(th), Math.sin(th)];\n        return [[c, s, 0], [-s, c, 0], [0, 0, 1]];\n    }\n    const xRot = th => {\n        let [c, s] = [Math.cos(th), Math.sin(th)];\n        return [[1, 0, 0], [0, c, s], [0, -s, c]];\n    }\n    // const rot = ths => mult2(mult2(zRot(ths[2]), xRot(ths[1])), zRot(ths[0]));\n    const invRot=ths=> mult2(mult2(zRot(-ths[0]),xRot(-ths[1])), zRot(-ths[2]));\n    const handlerShape = newShape => {\n        setShape(newShape);\n        let newZAxis = !newShape ? 0 : (newShape === 1 || newShape === 2) ? 1 : 2;\n        let newRunning = false;\n        let newTime = 0;\n        let newDegeneracies = [[false, false, false], [true, true, true], [false, true, true],    [false,    false, false]][newShape];\n        let newFirstMoms = [...firstMoms];\n        if (newShape === 1) newFirstMoms = firstMoms.map((mom, i, moms) => moms[0])\n        if (newShape === 2) {\n            newFirstMoms[1] += (firstMoms[0] === firstMoms[1] ) ? 1 : 0;\n            newFirstMoms[2] = firstMoms[1];\n        }\n        if (newShape === 3) {\n            newFirstMoms.sort((a, b) => a - b);\n            newFirstMoms[1] += (newFirstMoms[1] === newFirstMoms[0] ? 1 : 0);\n            newFirstMoms[2] += (newFirstMoms[2] === newFirstMoms[1] ? 1 : newFirstMoms[2] < newFirstMoms[1] ? 2 : 0);\n        }\n        let newMomsInput = newFirstMoms.map(mom => String(mom));\n        let newMoms = [...newFirstMoms];\n        // let newTypes = [[''], ['generic'], ['parallel', 'transverse'], ['longest',    'intermediate', 'shortest']][newShape];\n        let newTypes = allTypes[newShape];\n        let newStabilities = allStabilities[newShape];\n        return {newShape, newZAxis, newRunning, newTime, newDegeneracies, newFirstMoms, newMomsInput, newMoms, newTypes, newStabilities};\n    }\n    const calcD = moms => {\n        let sumMom = moms[0] + moms[1] + moms[2];\n        let newD = moms.map(mom => Math.max(0.000001, Math.sqrt((sumMom / 2 - mom))));\n        let dMax = newD.reduce((max, d) => Math.max(d, max));\n        newD = newD.map(d => npx * d / dMax / 4);\n        const newMids0 = [];\n        xyz.forEach((row, i) => {\n            let mid1 = [...xyz];\n            mid1[i] = newD[i];\n            let mid2 = [...xyz];\n            mid2[i] = -newD[i];\n            newMids0.push(mid1, mid2);\n        })\n        return {newD, newMids0};\n    }\n    useEffect(() => {\n        let state = calcD(moms);\n        setD(state.newD);\n        setMids0(state.newMids0);\n    }, [moms]);\n    useEffect(() => {\n        let state = handlerShape(shape);\n        setShape(state.newShape);\n        setZAxis(state.newZAxis);\n        setRunning(state.newRunning);\n        setTime(state.newTime);\n        setFirstMoms(state.newFirstMoms);\n        setMomsInput(state.newMomsInput);\n        setTypes(state.newTypes);\n        setStabilities(state.newStabilities);\n        state = calcSwitchedMoms(state.newZAxis, state.newMoms);\n        setMoms(state.newMoms);\n        setDegeneracies(state.newDegeneracies);\n        state = calcD(state.newMoms);\n        setD(state.newD);\n        setMids0(state.newMids0);\n    }, []);\n    const rotationStuff = () => {\n        setMids(mids0.map((mid, i) => mult1(invRot(ths), mid)));\n        let newAngleVec = rotate(invRot(ths));\n        let dot = angleVec[1] ? newAngleVec[1].reduce((dot, comp, i) => dot + comp * angleVec[1][i], 0) : null;\n        if (dot < 0) {\n            newAngleVec[1] = newAngleVec[1].map(comp => -comp);\n            newAngleVec[0] *= -1;\n        }\n        let nAng = (newAngleVec[0] - angleVec[0]) / 2 / Math.PI;\n        if (Math.abs(Math.round(nAng) - nAng) < 0.1) newAngleVec[0] -= Math.round(nAng) * 2 * Math.PI;\n        setAngleVec(newAngleVec);\n    }\n    useEffect(rotationStuff, [mids0, ths]);\n    const rotate = mat => {\n        let trace = mat[0][0] + mat[1][1] + mat[2][2];\n        let angle = Math.acos((trace - 1) / 2);\n        let vectors = new EigenvalueDecomposition(new Matrix(mat)).eigenvectorMatrix.transpose().data;\n        // Determine which eigenvector has eigenvalue = 1 (ie, is rotation axis)\n        let dVectors = vectors.map(vector => mult1(mat, vector).map((comp, i) => comp - vector[i]));\n        let mags = dVectors.map(dVector => dVector.reduce((mag, comp) => mag + comp * comp, 0));\n        let min = mags.reduce((min, mag, i) => mag < min[1] ? [i, mag] : min, [-1, Infinity]);\n        let axisVec = vectors[min[0]];\n        let vec = vectors[(min[0] + 1) % 3];\n        let rVec = mult1(mat, vec);\n        // rewrite this using a double loop or double list-comprehension?\n        let rVecCrossVec = [rVec[1] * vec[2] - rVec[2] * vec[1],\n                            rVec[2] * vec[0] - rVec[0] * vec[2],\n                            rVec[0] * vec[1] - rVec[1] * vec[0]];\n        angle *= Math.sign(dotproduct(axisVec, rVecCrossVec));\n        return [angle, axisVec];\n    }\n    const handlerMom = e => {\n        let newIsotropic = false;\n        let newMoms = [...firstMoms];\n        let name = Number(e.target.name);\n        // singularities occur if a moment equals zero\n        let newMom = Math.max(0.00001, Number(e.target.value));\n        newMoms[name] = newMom;\n        if (shape === 1) {\n            newMoms[1] = newMom;\n            newMoms[2] = newMom;\n        }\n        if (shape === 2) {\n            if (name === 1) newMoms[2] = newMom;\n            if (newMoms[0] === newMoms[1]) newIsotropic = true;\n        }\n        if (shape === 3) setLegalOrder(newMoms.reduce((legal, mom, i, moms) => (!i || (legal && mom > moms[i - 1])), true));\n        setAreLegalMoms(newMoms.reduce((legal, mom, i, moms) => (legal && mom <= (moms[(i+1)%3] + moms[(i+2)%3])), true));\n        setIsotropic(newIsotropic);\n        setFirstMoms(newMoms);\n        setMoms([...newMoms]);\n    };\n    const calcSwitchedMoms = (zAxis, moms) => {\n        let newMoms = [...moms];\n        newMoms[2] = firstMoms[(zAxis - 1) % 3];\n        newMoms[0] = firstMoms[(zAxis + 0) % 3];\n        newMoms[1] = firstMoms[(zAxis + 1) % 3];\n        // set as \"true\" for all axes for which moments of inertia are degenerate\n        let newDegeneracies = newMoms.map((momI, i) => {\n            return newMoms.reduce((degenerate, momJ, j) => {\n                return degenerate || (momJ === momI && i !== j);\n            }, false);\n        })\n        return {newMoms, newDegeneracies};\n    }\n    useEffect(() => {\n        let state = calcSwitchedMoms(zAxis, moms);\n        setMoms(state.newMoms);\n        setDegeneracies(state.newDegeneracies);\n    }, [zAxis]);\n    const handlerZAxis = newZAxis => {\n        calcSwitchedMoms(newZAxis, moms);\n        setZAxis(newZAxis);\n        setRunning(false);\n        setTime(0);\n        // setOms([0, 0, 0]);\n        setOmfs([0, 0, 0]);\n    }\n    const handlerTh = e => {\n        let newThs = [...ths];\n        newThs[Number(e.target.name)] = Number(e.target.value);\n        setThs(newThs);\n        let newMids = [];\n        mids0.forEach(mid => newMids.push(mult1(invRot(ths), mid)));\n        setMids(newMids);\n    };\n    useEffect(() => {\n        let interval;\n        if (running) interval = setInterval(() => setTime(time + dt/1000), dt);\n        if (!running && time !== 0) clearInterval(interval);\n        return () => clearInterval(interval);\n    }, [running, time, dt]);\n    const Fs = ths => {\n        let cs = [];\n        let ss = [];\n        for (const th of ths) {\n            cs.push(Math.cos(th));\n            ss.push(Math.sin(th));\n        };\n        let Fs = []\n        Fs[0] = Lz * (cs[2] * cs[2] / moms[1] + ss[2] * ss[2] / moms[0]);\n        Fs[1] = Lz * (1 / moms[0] - 1 / moms[1]) * ss[1] * ss[2] * cs[2];\n        Fs[2] = Lz * (1 / moms[2] - cs[2] * cs[2] / moms[1] - ss[2] * ss[2] / moms[0]) * cs[1];\n        let newOms = [];\n        newOms[0] = Fs[0] * ss[1] * ss[2] + Fs[1] * cs[2];\n        newOms[1] = Fs[0] * ss[1] * cs[2] - Fs[1] * ss[2];\n        newOms[2] = Fs[0] * cs[1] + Fs[2];\n        setOms(newOms);\n        // setOm2(newOms.reduce((om2, om) => om2 + om * om, 0));\n        let newOmfs = [];\n        newOmfs[0] = Fs[2] * ss[1] * ss[0] + Fs[1] * cs[0];\n        newOmfs[1] =-Fs[2] * ss[1] * cs[0] + Fs[1] * ss[0];\n        newOmfs[2] = Fs[2] * cs[1] + Fs[0];\n        setOmfs(newOmfs);\n        let newOmf = Math.sqrt(newOmfs.reduce((om2, om) => om2 + om * om, 0));\n        setOmf(newOmf);\n        setomfLat(Math.sqrt(newOmfs[0] * newOmfs[0] + newOmfs[1] * newOmfs[1]) / newOmf);\n        let newOmfAng = Math.atan2(omfs[1], omfs[0]);\n        let nAng = (newOmfAng - omfAng) / 2 / Math.PI;\n        if (Math.abs(Math.round(nAng) - nAng) < 0.2) newOmfAng -= Math.round(nAng) * 2 * Math.PI;\n        setOmfAng(newOmfAng);\n        let newLs = newOms.map((om, i) => moms[i] * om);\n        setLs(newLs);\n        // setL2(newLs.reduce((L2, L) => L2 + L * L, 0));\n        // setLabLs(mult1(invRot(ths), newLs));\n        setK(newLs.reduce((K, L, i) => K + L * oms[i], 0)/2);\n        // setK(Lz * (Fs[0] * cs[1] + Fs[2]));\n        return Fs;\n    }\n    const nextFs = (intFs, m) => Fs(ths.map((th, i) => th + intFs[i] * dt / 1000 / m));\n    // With each \"tick\", calculate the next set of 3 Euler angles\n    useEffect(() => {\n        if (!running) return;\n        let Fs1 = Fs(ths);\n        let Fs2 = nextFs(Fs1, 2);\n        let Fs3 = nextFs(Fs2, 2);\n        let Fs4 = nextFs(Fs3, 1);\n        setThs([...ths].map((th, i) => th + (Fs1[i] + Fs4[i] + 2 * (Fs2[i] + Fs3[i])) * dt/ 1000 / 6));\n    }, [time, running]);\n    const handleToggle = e => {\n        let name = e.currentTarget.name;\n        let newShowInfo = {...showInfo};\n        newShowInfo[name] = !showInfo[name];\n        setShowInfo(newShowInfo);\n    }\n    let text = {\n        timestep: `This controls the extent of the approximation used when computing derivatives with respect to time.  Shorter timesteps make the results more accurate but may make the simulation run slowly.`,\n        momentum: `Roughly speaking the angular momentum is the product of the body's mass, its width (away from the rotation axis), and how fast it spins.  The coordinate system for this simulation has x to the right, y down, and z into the screen.  Accordingly the z component of the angular momentum is positive for clockwise motion and negative for counterclockwise. If you want to see the body spin faster, increase its angular momentum.`,\n        shape: `An object has three moments of inertia: one for rotation about each of its three axes.  (Note that the axes are mutually perpendicular and are indicated in the figure.) An object is said to be \"isotropic\" if its three moments are all equal, as is the case for either a sphere or a cube. An object is \"axisymmetric\" if two out of the three moments are equal, as is the case either for an object which has \"rotational symmetry\" such as a cup, or a for box for which four of the six faces are the same shape.  An object is asymmetric if all three of its moments of inertia are different.`,\n        moment: `The moment of inertia quantifies an object's resistance to instantaneous changes of its rate of rotation, just as an object's mass (or \"translational inertia\") quantifies an object's resistance to instantaneous changes of its speed.  The moment of inertia about a particular axis is small if the object is \"skinny\" along that axis.`,\n        choose: `When one of the body's principal axes is exactly parallel to the z-axis (which - in turn - is parallel to the angular momentum vector), the rotational motion is constant, as you can easily confirm with this simulation.  However when the principal axis is close to - but does not coincide with - the z-axis the result is precession, which can be either stable or unstable.`,\n        euler: `Three angular parameters are required in order to specify the orientation of a rigid object which is free to rotate about its center of mass.  In aviation these variables are called \"pitch\", \"roll\", and \"yaw\", but in general these are usually chosen as the Euler angles, typically represented by the Greek letters \"phi\", \"theta\", and \"psi\" as used below.  For this simulation, the middle angle (between the body axis and the z-axis) is the most important, because it relates directly to precession of the body's axes.  The easiest way for you to learn more about these angles is by seeing the effects of their adjustment upon the body's appearance.`,\n        omega: `The body's angular velocity (or \"angular frequency\") is a vector which points in the same general direction as the body's angular-momentum vector, and these two vectors are exactly parallel if the angular momentum points exactly parallel to one of the body's principal axes of rotation.  The diagram on the right will use a dot to represent the angular velocity if/when it is ever parallel to the z-axis, because the vector will then be directed either into or out of the screen.`,\n        energy: `The body's rotational kinetic energy equals 0.5 times the \"dot product\" of the angular momentum and the angular velocity.  It is a non-negative quantity and should be constant in this simulation.  If it seems NOT to be constant, you should probably lower the value of the time-step.`,\n    }\n    return (\n        <>\n            <div className=\"top\"><h1><p align=\"center\">Free-body rotation</p></h1></div>\n            {`The motion of a rigid body consists of two simultaneous processes: (1) \"translation\" of the center of mass and (2) rotation around the center of mass.  The trajectory of the first process is either a straight line (in outer space), a parabola (near the surface of a gravitating body like the earth), or a conic section such as a circle, ellipse, or hyperbola (at a greater distance from a gravitating body).  This simulation considers the second process: the torque-free rotation of an object.  Except for the simple case of a body shaped as either a sphere or cube, this rotation is not as simple as that of a globe which spins at a constant rate about its fixed axis.  Free rotation is governed by \"Euler's torque-free equations\", a system of three nonlinear differential equations which generally can only be solved numerically as I do in this simulation. Almost every control/input/output below has a place where you can click`}\n            '<img src={info} alt=\"Show information.\" />/<img src={cancel} alt=\"Hide information.\" />'\n            {`in order to toggle the display of information about the particular item. Enjoy!`}\n            <div className=\"bottom\">\n                <div className=\"left\">\n                    <h3><p align=\"center\">Controls</p></h3>\n                    {!zAxis ? null :\n                        <>\n                            <button onClick={() => setRunning(!running)}>{running ? \"Stop\" : \"Start\"}</button>\n                            <button onClick={() => setTime(0)}>Reset</button>\n                            Time = {time.toFixed(1)} s\n                            <div>\n                                <ToggleInfo onClick={handleToggle} name=\"timestep\" toggle={showInfo.timestep} />\n                                Time-step (now {dt} ms):&nbsp;&nbsp;&nbsp;\n                                1 ms\n                                <input\n                                    type=\"range\" min=\"0\" max=\"11\" value={logDt} onChange={e => {\n                                        let newLogDt = Number(e.target.value);\n                                        setLogDt(newLogDt);\n                                        setDt(2 ** newLogDt);\n                                    }}\n                                />\n                                2 s\n                            </div>\n                            <div><i>{showInfo.timestep ? text.timestep : null}</i></div>\n                        </>\n                    }\n                    <>\n                        <div>\n                            Window size:&nbsp;&nbsp;&nbsp;\n                            small\n                            <input\n                                type=\"range\" min=\"400\" max=\"1000\" step=\"50\" value={npx}\n                                    onChange={e => setNpx(Number(e.target.value))}\n                            />\n                            large\n                        </div>\n                        <div>\n                            Perspective:&nbsp;&nbsp;&nbsp;\n                            lots\n                            <input\n                                type=\"range\" min={npx / 2} max={3 * npx} value={perspective}\n                                    onChange={e => setPerspective(Number(e.target.value))}\n                            />\n                            little\n                        </div>\n                    </>\n                    <h3><p align=\"center\">Inputs</p></h3>\n                    <div>\n                        <ToggleInfo onClick={handleToggle} name=\"momentum\" toggle={showInfo.momentum} />\n                        <i>z</i>-component of angular momentum: &nbsp;&nbsp;&nbsp;\n                        <InputNumber quantity={Lz} handler={e => setLz(Number(e.target.value))} /> kg m/s\n                    </div>\n                    <div>(The other two components are zero.)</div>\n                    <div><i>{showInfo.momentum ? text.momentum : null}</i></div>\n                    <div>\n                        <ToggleInfo onClick={handleToggle} name=\"shape\" toggle={showInfo.shape} />\n                        Shape of box: &nbsp;&nbsp;&nbsp;\n                        <select value={shape} onChange={e => {\n                            let state = handlerShape(Number(e.target.value));\n                            setShape(state.newShape);\n                            setZAxis(state.newZAxis);\n                            setRunning(state.newRunning);\n                            setTime(state.newTime);\n                            setDegeneracies(state.newDegeneracies);\n                            setFirstMoms(state.newFirstMoms);\n                            setMomsInput(state.newMomsInput);\n                            setMoms(state.newMoms);\n                            setTypes(state.newTypes);\n                            setStabilities(state.newStabilities);\n                        }} >\n                            {[\"choose shape\", 'isotropic', 'axisymmetric', 'asymmetric'].map((option, i) => (\n                                <option key={i} value={i}\n                                    title={[\"\", \"cubic\", \"box for pizza or champagne\", \"book-shaped\"][i]}>\n                                    {option}\n                                </option>\n                            ))}\n                        </select>\n                    </div>\n                    <div><i>{showInfo.shape ? text.shape : null}</i></div>\n                    {!shape ? null :\n                        <>\n                            <div>\n                                <ToggleInfo onClick={handleToggle} name=\"moment\" toggle={showInfo.moment} />\n                                Moment{`${shape === 1 ? '' : \"s\"}`} of inertia: (in kg m<sup>2</sup>)\n                            </div>\n                            <div><i>{showInfo.moment ? text.moment : null}</i></div>\n                            {xyz.filter((blah, i) => i < shape).map((blah, i) => (\n                                <InputNumber\n                                    key={i} name={i} quantity={firstMoms[i]}\n                                    handler={handlerMom} exceedsZero={true}\n                                    type={types[i] + \" axis\"}\n                                />\n                            ))}\n                            {legalOrder ? null :\n                                <div className=\"message\">\n                                    For an asymmetric body the moments of inertia should increase, going from long axis to short axis.\n                                </div>\n                            }\n                            {areLegalMoms ? null :\n                                <div className=\"message\">\n                                    No single moment of inertia should  exceed the sum of the other two.\n                                </div>\n                            }\n                            {!isotropic ? null :\n                                <div className=\"message\">\n                                    This is considered \"isotropic\" not \"axisymmetric\".\n                                </div>\n                            }\n                            {shape < 1 ? null :\n                                <>\n                                    <div>\n                                        <ToggleInfo onClick={handleToggle} name=\"choose\" toggle={showInfo.choose}   />\n                                        Choose <i>z</i>-axis to be near ...&nbsp;&nbsp;&nbsp;\n                                        <select value={zAxis} onChange={e => handlerZAxis(Number(e.target.value))} >\n                                            {[\"which\", ...types].map((option, i) => (\n                                                <option\n                                                    key={i} value={i}\n                                                    title={['', ...stabilities][i]}\n                                                >\n                                                    {option}\n                                                </option>\n                                            ))}\n                                        </select> axis.\n                                    </div>\n                                    <i>{showInfo.choose ? text.choose : null}</i>\n                                    <h3><p align=\"center\">{zAxis && time ? \"Data\" : null}</p></h3>\n                                    {!zAxis ? null :\n                                        <>\n                                            <div>\n                                                <ToggleInfo onClick={handleToggle} name=\"euler\" toggle={showInfo.euler} />\n                                                Euler angles (in radians):\n                                            </div>\n                                            <div><i>{showInfo.euler ? text.euler : null}</i></div>\n                                            <div>\n                                                between {types[zAxis - 1]} axis and <i>z</i>-axis: &nbsp;&nbsp;&nbsp;\n                                                &theta; =\n                                                <InputNumber\n                                                    key={\"ang1\"} name={1} handler= {handlerTh}\n                                                    quantity={ths[1]}\n                                                />\n                                            </div>\n                                            <div>\n                                                Remaining two angles: &nbsp;&nbsp;&nbsp;\n                                                &phi; =\n                                                <InputNumber\n                                                    key={\"ang0\"} name={0} handler={handlerTh}\n                                                    quantity={ths[0]}\n                                                />\n                                                &nbsp;&nbsp;&nbsp;\n                                                &psi; =\n                                                <InputNumber\n                                                    key={\"ang2\"} name={2} handler={handlerTh}\n                                                    quantity={ths[2]}\n                                                />\n                                            </div>\n                                        </>\n                                    }\n                                </>\n                            }\n                            {!(running || time) ? null :\n                                <>\n                                    <div>\n                                        <ToggleInfo onClick={handleToggle} name=\"omega\" toggle={showInfo.omega} />\n                                        Lab-frame angular velocity &omega; (in rad/sec)\n                                        <div>(also displayed as a segment in figure):</div>\n                                    </div>\n                                    <div><i>{showInfo.omega ? text.omega : null}</i></div>\n                                    <div>components = [\n                                        {Math.round(omfs[0] * 100) / 100},&nbsp;\n                                        {Math.round(omfs[1] * 100) / 100},&nbsp;\n                                        {Math.round(omfs[2] * 100) / 100}\n                                        ]\n                                    </div>\n                                    <div>magnitude = {Math.round(omf * 100) / 100}</div>\n\n                                    <div>\n                                        <ToggleInfo onClick={handleToggle} name=\"energy\" toggle={showInfo.energy}   />\n                                        kinetic energy = {Math.round(1000 * K) / 1000} joules\n                                    </div>\n                                    <div><i>{showInfo.energy ? text.energy : null}</i></div>\n                                </>\n                            }\n                        </>\n                    }\n                    <br/>creator: <a href=\"https://pknipp.github.io/\" target=\"_blank\">Peter Knipp</a>\n                </div>\n                <div className=\"container\" style={{height:`${npx}px`, width:`${npx}px`, perspective:`${perspective}px`}}>\n                    <Line npx={npx} r={omfLat * npx / 2} angle={omfAng} dt={dt} time={time} />\n                    <Body npx={npx} angleVec={angleVec} d={d} dt={dt} mids={mids0} degeneracies={degeneracies} running={running} />\n                    <Dot x={npx/2} y={npx/2} d={10} />\n                </div>\n            </div>\n        </>\n    )\n}\nexport default App;\n","/Users/pknipp/Desktop/repos/front-ends/rotating-body/src/InputNumber.js",[],"/Users/pknipp/Desktop/repos/front-ends/rotating-body/src/ToggleInfo.js",[],"/Users/pknipp/Desktop/repos/front-ends/rotating-body/src/Body.js",[],["42","43"],"/Users/pknipp/Desktop/repos/front-ends/rotating-body/src/Dot.js",[],"/Users/pknipp/Desktop/repos/front-ends/rotating-body/src/Line.js",[],{"ruleId":"44","replacedBy":"45"},{"ruleId":"46","replacedBy":"47"},{"ruleId":"48","severity":1,"message":"49","line":19,"column":22,"nodeType":"50","messageId":"51","endLine":19,"endColumn":33},{"ruleId":"52","severity":1,"message":"53","line":111,"column":8,"nodeType":"54","endLine":111,"endColumn":14,"suggestions":"55"},{"ruleId":"52","severity":1,"message":"56","line":128,"column":8,"nodeType":"54","endLine":128,"endColumn":10,"suggestions":"57"},{"ruleId":"52","severity":1,"message":"58","line":141,"column":30,"nodeType":"54","endLine":141,"endColumn":42,"suggestions":"59"},{"ruleId":"52","severity":1,"message":"60","line":198,"column":8,"nodeType":"54","endLine":198,"endColumn":15,"suggestions":"61"},{"ruleId":"52","severity":1,"message":"62","line":267,"column":8,"nodeType":"54","endLine":267,"endColumn":23,"suggestions":"63"},{"ruleId":"64","severity":1,"message":"65","line":472,"column":71,"nodeType":"66","endLine":472,"endColumn":86},{"ruleId":"44","replacedBy":"67"},{"ruleId":"46","replacedBy":"68"},"no-native-reassign",["69"],"no-negated-in-lhs",["70"],"no-unused-vars","'setThsInput' is assigned a value but never used.","Identifier","unusedVar","react-hooks/exhaustive-deps","React Hook useEffect has a missing dependency: 'calcD'. Either include it or remove the dependency array.","ArrayExpression",["71"],"React Hook useEffect has missing dependencies: 'calcD', 'calcSwitchedMoms', 'handlerShape', and 'shape'. Either include them or remove the dependency array.",["72"],"React Hook useEffect has missing dependencies: 'angleVec', 'invRot', 'mult1', and 'rotate'. Either include them or remove the dependency array.",["73"],"React Hook useEffect has missing dependencies: 'calcSwitchedMoms' and 'moms'. Either include them or remove the dependency array.",["74"],"React Hook useEffect has missing dependencies: 'Fs', 'dt', 'nextFs', and 'ths'. Either include them or remove the dependency array. You can also do a functional update 'setThs(t => ...)' if you only need 'ths' in the 'setThs' call.",["75"],"react/jsx-no-target-blank","Using target=\"_blank\" without rel=\"noreferrer\" is a security risk: see https://html.spec.whatwg.org/multipage/links.html#link-type-noopener","JSXAttribute",["69"],["70"],"no-global-assign","no-unsafe-negation",{"desc":"76","fix":"77"},{"desc":"78","fix":"79"},{"desc":"80","fix":"81"},{"desc":"82","fix":"83"},{"desc":"84","fix":"85"},"Update the dependencies array to be: [calcD, moms]",{"range":"86","text":"87"},"Update the dependencies array to be: [calcD, calcSwitchedMoms, handlerShape, shape]",{"range":"88","text":"89"},"Update the dependencies array to be: [angleVec, invRot, mids0, mult1, rotate, ths]",{"range":"90","text":"91"},"Update the dependencies array to be: [calcSwitchedMoms, moms, zAxis]",{"range":"92","text":"93"},"Update the dependencies array to be: [time, running, Fs, ths, nextFs, dt]",{"range":"94","text":"95"},[5532,5538],"[calcD, moms]",[6156,6158],"[calcD, calcSwitchedMoms, handlerShape, shape]",[6787,6799],"[angleVec, invRot, mids0, mult1, rotate, ths]",[9539,9546],"[calcSwitchedMoms, moms, zAxis]",[12434,12449],"[time, running, Fs, ths, nextFs, dt]"]