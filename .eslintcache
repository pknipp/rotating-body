[{"/Users/pknipp/Desktop/repos/react-frontend-template/src/index.js":"1","/Users/pknipp/Desktop/repos/react-frontend-template/src/App.js":"2","/Users/pknipp/Desktop/repos/rotating-body/src/index.js":"3","/Users/pknipp/Desktop/repos/rotating-body/src/App.js":"4","/Users/pknipp/Desktop/repos/rotating-body/src/Input.js":"5","/Users/pknipp/Desktop/repos/rotating-body/src/Square.js":"6","/Users/pknipp/Desktop/repos/rotating-body/src/Line.js":"7","/Users/pknipp/Desktop/repos/rotating-body/src/Body.js":"8"},{"size":506,"mtime":1611765216984,"results":"9","hashOfConfig":"10"},{"size":64,"mtime":1611765000156,"results":"11","hashOfConfig":"10"},{"size":506,"mtime":1611765216984,"results":"12","hashOfConfig":"13"},{"size":13010,"mtime":1615415075137,"results":"14","hashOfConfig":"13"},{"size":277,"mtime":1614868637876,"results":"15","hashOfConfig":"13"},{"size":858,"mtime":1615332940600,"results":"16","hashOfConfig":"13"},{"size":717,"mtime":1615334427283,"results":"17","hashOfConfig":"13"},{"size":2223,"mtime":1615388152117,"results":"18","hashOfConfig":"13"},{"filePath":"19","messages":"20","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},"1s2inzs",{"filePath":"21","messages":"22","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"23","messages":"24","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"25"},"3yxk78",{"filePath":"26","messages":"27","errorCount":0,"warningCount":5,"fixableErrorCount":0,"fixableWarningCount":0,"source":"28","usedDeprecatedRules":"25"},{"filePath":"29","messages":"30","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"25"},{"filePath":"31","messages":"32","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"25"},{"filePath":"33","messages":"34","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"25"},{"filePath":"35","messages":"36","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"37","usedDeprecatedRules":"38"},"/Users/pknipp/Desktop/repos/react-frontend-template/src/index.js",[],"/Users/pknipp/Desktop/repos/react-frontend-template/src/App.js",[],"/Users/pknipp/Desktop/repos/rotating-body/src/index.js",[],["39","40"],"/Users/pknipp/Desktop/repos/rotating-body/src/App.js",["41","42","43","44","45"],"import React, { useState, useEffect } from \"react\";\nimport { EigenvalueDecomposition, Matrix } from \"ml-matrix\";\n// import Dot from \"./Dot\";\nimport Input from \"./Input\";\nimport Line from \"./Line\";\nimport Square from \"./Square\";\nimport Body from \"./Body\";\n\nconst App = () => {\n    const nx = 700;\n    const ny = 700;\n    // const nz = ny;\n    // following is solely needed for list comprehensions\n    const [xyz] = useState(new Array(3).fill(0));\n    const colors = [\"red\", \"green\", \"blue\"];\n    const [h] = useState(1);\n    const [thsInput, setThsInput] = useState([\"0\", \"0.1\", \"0\"]);\n    const [ths, setThs] = useState(thsInput.map(elem => Number(elem)));\n    const [momsInput, setMomsInput] = useState([\"1\", \"3\", \"2\"]);\n    const [moms, setMoms] = useState(momsInput.map(elem => Number(elem)));\n    const [omsInput] = useState([\"\", \"\", \"\"]);\n    const [oms, setOms] = useState(omsInput.map(elem => Number(elem)));\n    const [omfs, setOmfs] = useState([0, 0, 0]);\n    const [, setLs] = useState([0, 0, 0]);\n    const [labLs, setLabLs] = useState([0, 0, 0]);\n    const [om2, setOm2] = useState(0);\n    const [omf2, setOmf2] = useState(0);\n    const [L2, setL2] = useState(0);\n    const [K, setK] = useState(0);\n    const [mids0, setMids0] = useState([]);\n    const [mids, setMids] = useState([]);\n    const [running, setRunning] = useState(false);\n    const [time, setTime] = useState(0);\n    const [angleVecs, setAngleVecs] = useState([[]]);\n    const [d, setD] = useState([nx / 3, nx / 3, nx / 3]);\n    const [areLegalMoms, setAreLegalMoms] = useState(true);\n\n    // ODE-solver timestep in ms\n    const dt = 50;\n\n    // helpful linear algebra functions:\n    const dotproduct = (vec1, vec2) => vec1.reduce((dot, comp, i) => dot + comp * vec2[i], 0);\n    // Can the following be expressed using map rather than reduce?\n    const mult1 = (mat, vec) => mat.reduce((prod, row, i) => [...prod, dotproduct(row, vec)], []);\n    const transpose = mat => mat[0].map((blah, i) => mat.map(row => row[i]));\n    const mult2 = (mat1, mat2) => mat1.map(x => transpose(mat2).map(y => dotproduct(x, y)));\n\n    const zRot = th => {\n        let [c, s] = [Math.cos(th), Math.sin(th)];\n        return [[c, s, 0], [-s, c, 0], [0, 0, 1]];\n    }\n    const xRot = th => {\n        let [c, s] = [Math.cos(th), Math.sin(th)];\n        return [[1, 0, 0], [0, c, s], [0, -s, c]];\n    }\n\n    // const rot = ths => mult2(mult2(zRot(ths[2]), xRot(ths[1])), zRot(ths[0]));\n    const invRot=ths=> mult2(mult2(zRot(-ths[0]),xRot(-ths[1])), zRot(-ths[2]));\n    const rotX = [[1, 0, 0], [0, 0,-1], [0, 1, 0]];\n    const rotY = [[0, 0,-1], [0, 1, 0], [1, 0, 0]];\n    const rotZ = [[1, 0, 0], [0, 1, 0], [0, 0, 1]];\n    // const invZ = [[1, 0, 0], [0, 1, 0], [0, 0,-1]];\n\n    useEffect(() => {\n        let sumMom = moms[0] + moms[1] + moms[2];\n        let newD = moms.map(mom => Math.sqrt((sumMom / 2 - mom)));\n        let dMax = newD.reduce((max, d) => Math.max(d, max));\n        newD = newD.map(d => nx * d / dMax / 4);\n        // let factor = Math.sqrt(moms.reduce((momMax, mom) => Math.max(momMax, mom), 0));\n        // // Fix the following, which assumes that D is proto moment along that axis\n        // let newD = moms.map(mom => Math.round(nx * Math.sqrt(mom)/factor/3));\n        setD(newD);\n        // replace this using reduce?\n        const newMids0 = [];\n        xyz.forEach((row, i) => {\n            let mid1 = [...xyz];\n            mid1[i] = newD[i];\n            let mid2 = [...xyz];\n            mid2[i] = -newD[i];\n            newMids0.push(mid1, mid2);\n        })\n        setMids0(newMids0);\n    }, [moms, xyz]);\n\n    const rotationStuff = () => {\n        setMids(mids0.map((mid, i) => mult1(invRot(ths), mid)));\n        let mats = [rotY, rotX, rotZ].map(mat => mult2(invRot(ths), mat));\n        let newAngleVecs = mats.map(mat => rotate(mat));\n        newAngleVecs.forEach((angleVec, i) => {\n        });\n        setAngleVecs(newAngleVecs);\n    }\n\n    useEffect(() => rotationStuff(), [mids0, ths]);\n\n    const rotate = mat => {\n        let trace = mat[0][0] + mat[1][1] + mat[2][2];\n        let angle = Math.acos((trace - 1) / 2);\n        let vectors = new EigenvalueDecomposition(new Matrix(mat)).eigenvectorMatrix.transpose().data;\n        // Determine which eigenvector has eigenvalue = 1 (ie, is rotation axis)\n        let dVectors = vectors.map(vector => mult1(mat, vector).map((comp, i) => comp - vector[i]));\n        let mags = dVectors.map(dVector => dVector.reduce((mag, comp) => mag + comp * comp, 0));\n        let min = mags.reduce((min, mag, i) => mag < min[1] ? [i, mag] : min, [-1, Infinity]);\n        let axisVec = vectors[min[0]];\n        let vec = vectors[(min[0] + 1) % 3];\n        let rVec = mult1(mat, vec);\n        // rewrite this using a double loop or double list-comprehension?\n        let rVecCrossVec = [rVec[1] * vec[2] - rVec[2] * vec[1],\n                            rVec[2] * vec[0] - rVec[0] * vec[2],\n                            rVec[0] * vec[1] - rVec[1] * vec[0]];\n        angle *= Math.sign(dotproduct(axisVec, rVecCrossVec));\n        // let angle2 = Math.asin(dotproduct(axisVec, rVecCrossVec));\n        // let angle3 = Math.atan2(dotproduct(axisVec, rVecCrossVec), (trace - 1) / 2);\n        return [angle, axisVec];\n    }\n\n    // consolidate following two event handlers?\n    const handlerTh = e => {\n        let xyOrZ = Number(e.target.name);\n        let th =  e.target.value;\n        let newThsInput = [...thsInput]\n        let newThs = [...ths];\n        if (th === '-' || th === '.' || th === '-.') {\n            newThsInput[xyOrZ] = th;\n        } else {\n            if (isNaN(Number(th))) return;\n            newThsInput[xyOrZ] = th;\n            newThs[xyOrZ] = Number(th);\n        }\n        setThsInput(newThsInput);\n        setThs(newThs);\n        let newMids = []; //JSON.parse(JSON.stringify(mids0));\n        mids0.forEach(mid => newMids.push(mult1(invRot(ths), mid)));\n        setMids(newMids);\n    };\n\n    const handlerMom = e => {\n        let xyOrZ = Number(e.target.name);\n        let mom = e.target.value;\n        console.log(\"mom = \", mom);\n        let newMomsInput = [...momsInput];\n        let newMoms = [...moms];\n        if (mom === '' || mom === '.') {\n            newMomsInput[xyOrZ] = mom;\n        } else {\n            let newMom = Number(mom);\n            if (isNaN(newMom)) return;\n            // calculate limits of the value of this new moment of inertia\n            let otherMoms = [...moms];\n            otherMoms.splice(xyOrZ, 1);\n            let maxOtherMom = Math.max(...otherMoms);\n            let minOtherMom = Math.min(...otherMoms);\n            let maxMom = maxOtherMom + minOtherMom;\n            let minMom = maxOtherMom - minOtherMom;\n            let newAreLegalMoms = !(mom < minMom || mom > maxMom);\n            newMomsInput[xyOrZ] = mom;\n            newMoms[xyOrZ] = newMom;\n            setAreLegalMoms(newAreLegalMoms);\n        }\n        setMomsInput(newMomsInput);\n        setMoms(newMoms);\n    };\n\n    useEffect(() => {\n        let interval = null;\n        if (running) {\n            interval = setInterval(() => {\n                setTime(time + dt/1000);\n                // nextThs();\n            }, dt);\n        } else if (!running && time !== 0) {\n            clearInterval(interval);\n        }\n        return () => clearInterval(interval);\n    }, [running, time]);\n\n    const Fs = ths => {\n        let cs = [];\n        let ss = [];\n        for (const th of ths) {\n            cs.push(Math.cos(th));\n            ss.push(Math.sin(th));\n        };\n        let Fs = []\n        Fs[0] = h * (cs[2] * cs[2] / moms[1] + ss[2] * ss[2] / moms[0]);\n        Fs[1] = h * (1 / moms[0] - 1 / moms[1]) * ss[1] * ss[2] * cs[2];\n        Fs[2] = h * (1 / moms[2] - cs[2] * cs[2] / moms[1] - ss[2] * ss[2] / moms[0]) * cs[1];\n        let newOms = [];\n        newOms[0] = Fs[0] * ss[1] * ss[2] + Fs[1] * cs[2];\n        newOms[1] = Fs[0] * ss[1] * cs[2] - Fs[1] * ss[2];\n        newOms[2] = Fs[0] * cs[1] + Fs[2];\n        setOms(newOms);\n        setOm2(newOms.reduce((om2, om) => om2 + om * om, 0));\n        let newOmfs = [];\n        newOmfs[0] = Fs[2] * ss[1] * ss[0] + Fs[1] * cs[0];\n        newOmfs[1] =-Fs[2] * ss[1] * cs[0] + Fs[1] * ss[0];\n        newOmfs[2] = Fs[2] * cs[1] + Fs[0];\n        setOmfs(newOmfs);\n        setOmf2(newOmfs.reduce((om2, om) => om2 + om * om, 0));\n        let newLs = newOms.map((om, i) => moms[i] * om);\n        setLs(newLs);\n        setL2(newLs.reduce((L2, L) => L2 + L * L, 0));\n        setLabLs(mult1(invRot(ths), newLs));\n        setK(newLs.reduce((K, L, i) => K + L * oms[i], 0)/2);\n        return Fs;\n    }\n\n    const nextFs = (intFs, m) => Fs(ths.map((th, i) => th + intFs[i] * dt / 1000 / m));\n\n    // With each \"tick\", calculate the next set of 3 Euler angles\n    useEffect(() => {\n        if (!running) return;\n        let Fs1 = Fs(ths);\n        let Fs2 = nextFs(Fs1, 2);\n        let Fs3 = nextFs(Fs2, 2);\n        let Fs4 = nextFs(Fs3, 1);\n        setThs([...ths].map((th, i) => th + (Fs1[i] + Fs4[i] + 2 * (Fs2[i] + Fs3[i])) * dt/ 1000 / 6));\n    }, [time, running]);\n\n    return (\n        <>\n            <button onClick={() => setRunning(!running)}>{running ? \"Stop\" : \"Start\"}</button>\n            <button onClick={() => setTime(0)}>Reset</button>\n            Time = {time.toFixed(2)} s\n            <table>\n                <thead>\n                    <tr>\n                        <th>Quantity</th>\n                        <th>x-comp</th>\n                        <th>y-comp</th>\n                        <th>z-comp</th>\n                        <th>magnit.</th>\n                    </tr>\n                </thead>\n                <tbody>\n                    <tr>\n                        <td>angles (rad)</td>\n                        <td><Input key={\"ang0\"} n={0} quantity={running || time ? ths[0] : thsInput[0]} handler={handlerTh} /></td>\n                        <td><Input key={\"ang1\"} n={1} quantity={running || time ? ths[1] : thsInput[1]} handler={handlerTh} /></td>\n                        <td><Input key={\"ang2\"} n={2} quantity={running || time ? ths[2] : thsInput[2]} handler={handlerTh} /></td>\n                        <td> - </td>\n                    </tr>\n                    <tr>\n                        <td>moments</td>\n                        <td><Input key={\"mom0\"} n={0} quantity={momsInput[0]} handler={handlerMom} /></td>\n                        <td><Input key={\"mom1\"} n={1} quantity={momsInput[1]} handler={handlerMom} /></td>\n                        <td><Input key={\"mom2\"} n={2} quantity={momsInput[2]} handler={handlerMom} /></td>\n                        <td>{areLegalMoms ? null : \"WARNING: No single moment of inertia should exceed the sum of the other two.\"}</td>\n                    </tr>\n                    <tr>\n                        <td>(body) omega</td>\n                        <td>{Math.round(oms[0] * 1000) / 1000}</td>\n                        <td>{Math.round(oms[1] * 1000) / 1000}</td>\n                        <td>{Math.round(oms[2] * 1000) / 1000}</td>\n                        <td>{Math.round(Math.sqrt(om2) * 1000) / 1000}</td>\n                    </tr>\n                    <tr>\n                        <td>(fixed) omega</td>\n                        <td>{Math.round(omfs[0] * 1000) / 1000}</td>\n                        <td>{Math.round(omfs[1] * 1000) / 1000}</td>\n                        <td>{Math.round(omfs[2] * 1000) / 1000}</td>\n                        <td>{Math.round(Math.sqrt(omf2) * 1000) / 1000}</td>\n                    </tr>\n                    <tr>\n                        <td>ang. mom</td>\n                        <td>{Math.round(labLs[0] * 1000) / 1000}</td>\n                        <td>{Math.round(labLs[1] * 1000) / 1000}</td>\n                        <td>{Math.round(labLs[2] * 1000) / 1000}</td>\n                        <td>{Math.round(1000 * Math.sqrt(L2) / 1000)}</td>\n                    </tr>\n                    <tr>\n                        <td>KE</td><td></td><td></td><td></td><td>{Math.round(1000 * K) / 1000}</td>\n                    </tr>\n                </tbody>\n            </table>\n            <div className=\"container\" style={{height:`${ny}px`, width:`${nx}px`}}>\n                {/* {angleVecs.map((angleVec, i) => (\n                    <>\n                        <Square key={`front${i}`} mids={mids} i={2 * i} nx={nx} ny={ny} d={d} angleVec={angleVec} color={colors[i]} />\n                        <Square key={`back${i}`} mids={mids} i={2*i+ 1} nx={nx} ny={ny} d={d} angleVec={angleVec} color={colors[i]} />\n                    </>\n                ))} */}\n                {/* <Line xi={nx/2} yi={ny/2} xf={nx * (1/2 + omfs[0])} yf={ny * (1/2 + omfs[1])} /> */}\n                {mids.map(mid => {\n                    <Line xi={nx/2} yi={ny/2} xf={nx * (0.5 + mid[0])} yf={ny * (0.5 + mid[1])} dashed={true} />\n                })}\n                <Line xi={nx/2} yi={ny/2} xf={nx * (1/2 + omfs[0])} yf={ny * (1/2 + omfs[1])} />\n                <Body nx={nx} ny={ny} angleVec={angleVecs[2]} d={d} />\n            </div>\n        </>\n    )\n}\nexport default App;\n","/Users/pknipp/Desktop/repos/rotating-body/src/Input.js",[],"/Users/pknipp/Desktop/repos/rotating-body/src/Square.js",[],"/Users/pknipp/Desktop/repos/rotating-body/src/Line.js",[],"/Users/pknipp/Desktop/repos/rotating-body/src/Body.js",["46"],"const Body = ({ nx, ny, angleVec, d }) => {\n    let is = [[2, 1], [0, 2], [0, 1]];\n    let angle = angleVec ? angleVec[0] : 0;\n    let axisVec = angleVec ? angleVec[1] : [0, 0, 1];\n    return (\n        <div className=\"body\" style={{\n            // position: \"relative\",\n            // width :`${2 * d[is[0]]}px`,\n            // height:`${2 * d[is[1]]}px`,\n            // left: `${nx /2}`,\n            // top: `${ny / 2}`,\n            // left: `${(nx / 2 - d[is[0]])}px`,\n            // top:  `${(ny / 2 - d[is[0]])}px`,\n            // left: `${nx / 2}`,\n            // top: `${ny / 2}`,\n            transform: `translateX(${nx/2}px) translateY(${ny/2}px) rotate3d(${axisVec[0]}, ${axisVec[1]}, ${-axisVec[2]},${angle}rad)`}}>\n            <div className=\"side\"  style={{transform: `rotateY(0deg) translateZ(${d[2]}px)`, background: \"rgba(100,0,0,0.8)\",\n                left: `${-d[0]}px`, top: `${-d[1]}px`, width:`${2 * d[0]}px`, height:`${2 * d[1]}px`\n            }}/>\n            <div className=\"side\" style={{transform: `rotateY(180deg) translateZ(${d[2]}px)`, background: \"rgba(100,0,0,0.8)\",\n                left: `${-d[0]}px`, top: `${-d[1]}px`, width:`${2*d[0]}px`, height:`${2*d[1]}px`\n            }}/>\n            <div className=\"side\" style={{transform: `rotateY(90deg) translateZ(${d[0]}px)`, background: \"rgba(0,100,0,0.8)\",\n                left: `${-d[2]}px`, top: `${-d[1]}px`,     width:`${2 * d[2]}px`, height:`${2*d[1]}px`\n            }}/>\n            <div className=\"side\" style={{transform: `rotateY(-90deg) translateZ(${d[0]}px)`, background: \"rgba(0,100,0,0.8)\",\n                left: `${-d[2]}px`, top: `${-d[1]}px`, width:`${2*d[2]}px`, height:`${2*d[1]}px`\n            }}/>\n            <div className=\"side\" style={{transform: `rotateX(90deg) translateZ(${d[1]}px)`, background: \"rgba(0,0,100,0.8)\",\n                left: `${-d[0]}px`, top: `${-d[2]}px`, width:`${2*d[0]}px`, height:`${2*d[2]}px`\n            }}/>\n            <div className=\"side\" style={{transform: `rotateX(-90deg) translateZ(${d[1]}px)`, background: \"rgba(0,0,100,0.8)\",\n                left: `${-d[0]}px`, top: `${-d[2]}px`, width:`${2*d[0]}px`, height:`${2*d[2]}px`\n            }}/>\n        </div>\n    )\n}\nexport default Body;\n",["47","48"],{"ruleId":"49","replacedBy":"50"},{"ruleId":"51","replacedBy":"52"},{"ruleId":"53","severity":1,"message":"54","line":6,"column":8,"nodeType":"55","messageId":"56","endLine":6,"endColumn":14},{"ruleId":"53","severity":1,"message":"57","line":15,"column":11,"nodeType":"55","messageId":"56","endLine":15,"endColumn":17},{"ruleId":"58","severity":1,"message":"59","line":94,"column":38,"nodeType":"60","endLine":94,"endColumn":50,"suggestions":"61"},{"ruleId":"58","severity":1,"message":"62","line":218,"column":8,"nodeType":"60","endLine":218,"endColumn":23,"suggestions":"63"},{"ruleId":"64","severity":1,"message":"65","line":284,"column":31,"nodeType":"66","messageId":"67","endLine":284,"endColumn":33},{"ruleId":"53","severity":1,"message":"68","line":2,"column":9,"nodeType":"55","messageId":"56","endLine":2,"endColumn":11},{"ruleId":"49","replacedBy":"69"},{"ruleId":"51","replacedBy":"70"},"no-native-reassign",["71"],"no-negated-in-lhs",["72"],"no-unused-vars","'Square' is defined but never used.","Identifier","unusedVar","'colors' is assigned a value but never used.","react-hooks/exhaustive-deps","React Hook useEffect has a missing dependency: 'rotationStuff'. Either include it or remove the dependency array.","ArrayExpression",["73"],"React Hook useEffect has missing dependencies: 'Fs', 'nextFs', and 'ths'. Either include them or remove the dependency array. You can also do a functional update 'setThs(t => ...)' if you only need 'ths' in the 'setThs' call.",["74"],"array-callback-return","Array.prototype.map() expects a return value from arrow function.","ArrowFunctionExpression","expectedInside","'is' is assigned a value but never used.",["71"],["72"],"no-global-assign","no-unsafe-negation",{"desc":"75","fix":"76"},{"desc":"77","fix":"78"},"Update the dependencies array to be: [mids0, rotationStuff, ths]",{"range":"79","text":"80"},"Update the dependencies array to be: [time, running, Fs, ths, nextFs]",{"range":"81","text":"82"},[3961,3973],"[mids0, rotationStuff, ths]",[9031,9046],"[time, running, Fs, ths, nextFs]"]